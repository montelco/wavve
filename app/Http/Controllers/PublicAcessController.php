<?php

namespace Wavvve\Http\Controllers;

use Wavvve\Pass;
use Wavvve\User;
use Wavvve\iOS_Registration;
use Wavvve\iOS_Pass;
use Illuminate\Http\Request;
use Passbook\Pass\Field;
use Passbook\Pass\Image;
use Passbook\Pass\Beacon;
use Passbook\PassFactory;
use Passbook\Pass\Barcode;
use Passbook\Pass\Structure;
use Passbook\Type\StoreCard;

class PublicAcessController extends Controller
{
    const WAVVVE_BASE_URL = '1f 02 01 06 03 03 aa fe 17 16 aa fe 10 00 03 77 61 76 76 76 65 2e 69 6f 2f ';

    public function fetchBeaconPayload($user_id, $hardware_id, $lat, $lon)
    {
        return response()->json(['payload' => self::WAVVVE_BASE_URL.rtrim(chunk_split(bin2hex(Pass::where('user_id', $user_id)->orderBy('updated_at', 'desc')->firstOrFail()['uuid']), 2, ' '), ' ')], 200);
    }

    public function iBeaconUUID($user_id, $hardware_id, $lat, $lon)
    {
        return response()->json(['payload' => self::WAVVVE_BASE_URL.rtrim(chunk_split(bin2hex('2b 4f cf 51 4e aa 44 6d b2 4e 4d 1b 43 7f 38 40'), 2, ' '), ' ')], 200);
    }

    public function getWalletCompiledPass($username)
    {
        $results = User::with(['passes' => function ($query) {
            $query->orderBy('updated_at', 'desc')->first();
        }])->where('username', $username)->firstOrFail();

        define('P12_FILE', '/home/forge/wavvve.io/ATMT.p12');
        define('P12_PASSWORD', '1234');
        define('WWDR_FILE', '/home/forge/wavvve.io/wwdr.pem');
        define('PASS_TYPE_IDENTIFIER', 'pass.com.atmt.wavvvetest2');
        define('TEAM_IDENTIFIER', '527AHA4RH7');
        define('ORGANIZATION_NAME', 'WavvveÂ® by ATMT');
        define('OUTPUT_PATH', '/home/forge/wavvve.io/public/business');
        define('ICON_FILE', '/home/forge/wavvve.io/public/tpw.png');

        // Create an event ticket
        $pass = new StoreCard($results->username, $results->username);
        $pass->setBackgroundColor('rgb(178, 215, 234)');
        //$pass->setLogoText('rgb(255,255,255)');
        $pass->setAuthenticationToken($results->apple_auth);
        $pass->setWebServiceURL('https://www.wavvve.io');
        $pass->setLogoText($results->name);
        $beacon = new Beacon('2b4fcf51-4eaa-446d-b24e-4d1b437f3840');
        $beacon->setMajor(0);
        $beacon->setMinor(0);
        $pass->addBeacon($beacon);

        // Create pass structure
        $structure = new Structure();

        // Add header field
        if(isset($results->passes['0']->title)) {
            $header = new Field('title', $results->passes['0']->title);
            $structure->addHeaderField($header);
        }

        // // Add primary field
        if(isset($results->passes['0']->primary_field)) {
            $primary = new Field('description', $results->passes['0']->primary_field);
            $structure->addPrimaryField($primary);
        }

        // Add back field
        if(isset($results->passes['0']->uuid)) {
            $backField = new Field('redirect', '<a href="https://www.wavvve.io/' . $results->passes['0']->uuid . '">View In Browser</a>');
            $structure->addBackField($backField);
        }
        
        // Add icon image
        $icon = new Image(ICON_FILE, 'icon');
        $pass->addImage($icon);

        // Set pass structure
        $pass->setStructure($structure);

        // Add barcode
        if(isset($results->passes['0']->barcode_value)) {
            $barcode = new Barcode(Barcode::TYPE_QR, $results->passes['0']->barcode_value);
            $pass->setBarcode($barcode);
        }

        // Create pass factory instance
        $factory = new PassFactory(PASS_TYPE_IDENTIFIER, TEAM_IDENTIFIER, ORGANIZATION_NAME, P12_FILE, P12_PASSWORD, WWDR_FILE);
        $factory->setOutputPath(OUTPUT_PATH);
        $factory->package($pass);

        //Insert records as required to maintain.
        iOS_Pass::create([
            'passTypeID' => PASS_TYPE_IDENTIFIER,
            'authorization_token'
        ]);

        return PassFactory::serialize($pass);
    }

    /**
     * This method handles interactions between the Wavvve production server and the Apple Push Noitification Service (APNs). It can register, delete, and notify subscribed users of updates to a Wallet pass's contents.
     * @param  string  $deviceID   The UUID generated by the Wallet application on an iOS Device.
     * @param  string  $passTypeID This is the Apple Developer issued pass type name (eg: "pass.com.atmt.example").
     * @param  string  $serial     This uniquely identifies the Wallet pass within the Wavvve platform and there is one per business username (eg: Churchill Coffee could have churchill-coffee as their unique serial).
     * @param  Request $request    This is the incoming request made by the APNs server and includes the Auth header field and the push token in the request body.
     * @return HTTP Response Code              This method returns the appropriate HTTP Response code given the logic and input.
     */
    
    public function postWallet($deviceID, $passTypeID, $serial, Request $request)
    {
        $uuid = $deviceID . "-" . $serial;
        if ($request->isMethod('post')) {
            //Validates the incoming request by comparing the authorization_token as well as the pass serial (eg: churchill-coffee.pkpass) where the 'churchill-coffee' is the serial
            if (iOS_Pass::where('serial_no', $serial)->where('authentication_token', substr($request->header('authorization'), 9))->firstOrFail()) {
                if (iOS_Registration::where('uuid', $uuid)->count() < 1) {
                    //Device isn't registered, but it's addable
                    iOS_Registration::create([
                        'uuid' => $uuid, 
                        'pass_type_id' => $passTypeID,
                        'push_token' => $request->pushToken,
                        'ios_devices_id' => $deviceID,
                        'ios_passes_serial' => $serial]);
                    return response(201);
                } else {
                    //Device is already registered. No further action is required.
                    return response(200);
                }
            } else {
                //This request cannot be determined to be authentic.
                return response(401);
            }
        } elseif ($request->isMethod('delete')) {
            //Validates the incoming request by comparing the authorization_token as well as the pass serial (eg: churchill-coffee.pkpass) where the 'churchill-coffee' is the serial
            if (iOS_Pass::where('serial_no', $serial)->where('authentication_token', substr($request->header('authorization'), 9))->firstOrFail()) {
                if (iOS_Registration::where('uuid', $uuid)->count() < 1) {
                    //Device isn't registered to the pass. This is an error, as a bad request has occurred.
                    return response(400);
                } else {
                    $unRegisterDevice = iOS_Registration::where('ios_devices_id', $deviceID)->where('ios_passes_serial', $serial)->firstOrFail();
                    $unRegisterDevice->delete();

                    //The deletion was successful. Return HTTP OK
                    return response(200);
                }
            } else {
                //This request was incorrectly formed either in serial number or in the authorization token.
                return response(401);
            }   
        } elseif ($request->isMethod('get')) {

        } else {
            return response(400);
        }
    }

    /**
     * This method handles update notifications on behalf of APNs Server for a given device.
     * @param  string  $deviceID   The UUID generated by the Wallet application on an iOS Device.
     * @param  string  $passTypeID This is the Apple Developer issued pass type name (eg: "pass.com.atmt.example").
     * @param  time $tag        This is the current time or the most recently updated_at time that the device has logged.
     * @return HTTP Response Code              This method returns the appropriate HTTP Response code given the logic and input.
     */
    public function updateWallet($deviceID, $passTypeID, $tag)
    {
        $tag = time();
        
        //Is it in our table of registered devices?
        if (iOS_Registration::where('ios_devices_id', $deviceID)->count() > 0) {
            //Yes, it's registered with our service.
            
            //Now grab all the passes to which this device is registered.
            $registered_serial_numbers = iOS_Registration::where('ios_devices_id', $deviceID)->where('pass_type_id', $passTypeID)->get('serial_no');
            if (isset($tag) && $tag != "") {
                //Tag is set and is not equal to a blank string.
                $registered_passes = iOS_Pass::where('serial_no', $registered_serial_numbers)->where('updated_at', '>=', $tag);
            } else {
                //Tag may not be set or is a blank string.
                $registered_passes = iOS_Pass::where('serial_no', $registered_serial_numbers);
            }

            //If there are passes that should be updated.
            if ($registered_passes > 0) {

                //Return a JSON formatted object.
                return response()->json(['lastUpdated' => time(), 'serialNumbers' => $registered_passes], 200);
            } else {

                //No content to return.
                return response(204);
            }
        } else {
            //No, it's not registered with our service.
            return response(404);
        }
    }

    public function pubAccess($uuid, Pass $pass)
    {
        $currentTime = date('Y-m-d H:i:s');
        $customerPass = Pass::where('uuid', $uuid)->firstOrFail();
        if ($customerPass === null) {
            return abort('500');
        } else {
            if ($customerPass->published <= $currentTime) {
                switch ($customerPass->template_number) {
                    case 1:
                        return view('pub.pass_pub_template_one')->with('pass', $customerPass);
                        break;
                    case 2:
                        return view('pub.pass_pub_template_two')->with('pass', $customerPass);
                        break;
                    case 3:
                        return view('pub.pass_pub_template_three')->with('pass', $customerPass);
                        break;
                }
            } else {
                return abort('404');
            }
        }
    }

    public function setFlowCookie()
    {
    }

    public function caching()
    {
        //Caching JSON output to run for service workers.
    }
}
